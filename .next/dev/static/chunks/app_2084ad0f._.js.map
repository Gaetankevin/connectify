{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/gaetan/Bureau/ReactJS%20Experiences/hello-prisma/app/actions/auth.ts"],"sourcesContent":["\"use server\";\n\nimport {\n  SignupFormSchema,\n  LoginFormSchema,\n  FormState,\n} from \"./../lib/definitions\";\nimport { prisma } from \"../../lib/prisma\";\nimport bcrypt from \"bcrypt\";\nimport { type User } from \"../../generated/prisma/client\";\nimport { createSession, destroySession } from \"../../lib/session\";\n\nexport async function signup(\n  prevState: FormState,\n  formData: FormData\n): Promise<FormState> {\n  const validatedFields = SignupFormSchema.safeParse({\n    name: formData.get(\"name\"),\n    surname: formData.get(\"surname\"),\n    username: formData.get(\"username\"),\n    email: formData.get(\"email\"),\n    password: formData.get(\"password\"),\n    confirmPassword: formData.get(\"confirmPassword\"),\n  });\n\n  // If any form fields are invalid, return early\n  if (!validatedFields.success) {\n    return {\n      errors: validatedFields.error.flatten().fieldErrors,\n    };\n  }\n\n  // 2. Prepare data for insertion into database\n  const { name, surname, username, email, password } = validatedFields.data;\n  // e.g. Hash the user's password before storing it\n  const hashedPassword = await bcrypt.hash(password, 10);\n  //il faudrait retourner l'id du user creer apres son inscription grace a prisma\n  const data = await prisma.user.create({\n    data: {\n      name: name,\n      surname: surname,\n      username: username,\n      email: email,\n      passwordHash: hashedPassword,\n      roleId: 3,\n      createdAt: new Date(),\n    },\n  });\n\n  const user: User = data;\n\n  if (!user) {\n    return {\n      message: \"An error occurred while creating your account.\",\n    };\n  }\n  // create a DB-backed session and set cookie\n  try {\n    await createSession(user.id);\n  } catch (e) {\n    // session creation failed â€” we still return success for account creation,\n    // but log or handle as needed. For now, return an error state.\n    return { message: \"User created but failed to create session.\" };\n  }\n\n  // Return a client-side redirect hint. The client can navigate to `/chat`\n  // when it sees this property in the action state.\n  return { message: \"User created successfully\", redirectTo: \"/chat\" };\n}\n\nexport async function login(\n  prevState: FormState,\n  formData: FormData\n): Promise<FormState> {\n  const validated = LoginFormSchema.safeParse({\n    username_email: formData.get(\"username_email\"),\n    password: formData.get(\"password\"),\n  });\n\n  if (!validated.success) {\n    return { errors: validated.error.flatten().fieldErrors };\n  }\n\n  const { username_email, password } = validated.data;\n\n  // find user by username or email\n  const user = await prisma.user.findFirst({\n    where: {\n      OR: [{ username: username_email }, { email: username_email }],\n    },\n  });\n\n  if (!user) {\n    return { errors: { username_email: [\"Invalid username or email\"] } };\n  }\n\n  const ok = await bcrypt.compare(password, user.passwordHash);\n  if (!ok) {\n    return { errors: { password: [\"Invalid password\"] } };\n  }\n\n  // create session\n  try {\n    await createSession(user.id);\n  } catch (e) {\n    return { message: \"Logged in but failed to create session.\" };\n  }\n\n  // Return a client-side redirect hint so the UI can navigate to /chat\n  return { message: \"Logged in successfully\", redirectTo: \"/chat\" };\n}\n\nexport async function logout() {\n  await destroySession();\n}\n"],"names":[],"mappings":";;;;;;;IAsEsB,QAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}},
    {"offset": {"line": 19, "column": 0}, "map": {"version":3,"sources":["file:///home/gaetan/Bureau/ReactJS%20Experiences/hello-prisma/app/lib/definitions.ts"],"sourcesContent":["import * as z from \"zod\";\nexport const SignupFormSchema = z\n  .object({\n    name: z\n      .string()\n      .min(2, { message: \"Name must be at least 2 characters long\" })\n      .max(50, { message: \"Name must be at most 50 characters long\" })\n      .trim(),\n    surname: z\n      .string()\n      .min(2, { message: \"Surname must be at least 2 characters long\" })\n      .max(50, { message: \"Surname must be at most 50 characters long\" })\n      .trim(),\n    username: z\n      .string()\n      .min(3, { message: \"Username must be at least 3 characters long\" })\n      .max(30, { message: \"Username must be at most 30 characters long\" })\n      .regex(/^[a-zA-Z0-9_]+$/, {\n        message: \"Username can only contain letters, numbers, and underscores.\",\n      })\n      .trim(),\n    email: z.email({ message: \"Invalid email address\" }),\n    password: z\n      .string()\n      .min(8, { message: \"Password must be at least 8 characters long\" })\n      .regex(/[a-zA-Z]/, { message: \"Contain at least one letter.\" })\n      .regex(/[0-9]/, { message: \"Contain at least one number.\" })\n      .regex(/[^a-zA-Z0-9]/, {\n        message: \"Contain at least one special character.\",\n      })\n      .trim(),\n    confirmPassword: z.string(),\n  })\n  .refine((data) => data.password === data.confirmPassword, {\n    path: [\"confirmPassword\"],\n    message: \"Passwords do not match\",\n  });\n\nexport type RegisterFormState =\n  | {\n      errors?: {\n        name?: string[];\n        surname?: string[];\n        username?: string[];\n        email?: string[];\n        password?: string[];\n        confirmPassword?: string[];\n      };\n      message?: string;\n    }\n  | undefined;\nexport const LoginFormSchema = z.object({\n  username_email: z.string().min(1, { message: \"Username or email is required\" }).trim(),\n  password: z.string().min(1, { message: \"Password is required\" }).trim(),\n})\n\nexport type FormState =\n  | {\n      errors?: {\n        [key: string]: string[] | undefined;\n      };\n      message?: string;\n      // optional client-side redirect hint. When returned by server actions\n      // the client can navigate to this path (e.g. '/chat') after success.\n      redirectTo?: string;\n    }\n  | undefined"],"names":[],"mappings":";;;;;;AAAA;;AACO,MAAM,mBAAmB,4JACvB,CAAC;IACN,MAAM,4JACG,GACN,GAAG,CAAC,GAAG;QAAE,SAAS;IAA0C,GAC5D,GAAG,CAAC,IAAI;QAAE,SAAS;IAA0C,GAC7D,IAAI;IACP,SAAS,4JACA,GACN,GAAG,CAAC,GAAG;QAAE,SAAS;IAA6C,GAC/D,GAAG,CAAC,IAAI;QAAE,SAAS;IAA6C,GAChE,IAAI;IACP,UAAU,4JACD,GACN,GAAG,CAAC,GAAG;QAAE,SAAS;IAA8C,GAChE,GAAG,CAAC,IAAI;QAAE,SAAS;IAA8C,GACjE,KAAK,CAAC,mBAAmB;QACxB,SAAS;IACX,GACC,IAAI;IACP,OAAO,2JAAO,CAAC;QAAE,SAAS;IAAwB;IAClD,UAAU,4JACD,GACN,GAAG,CAAC,GAAG;QAAE,SAAS;IAA8C,GAChE,KAAK,CAAC,YAAY;QAAE,SAAS;IAA+B,GAC5D,KAAK,CAAC,SAAS;QAAE,SAAS;IAA+B,GACzD,KAAK,CAAC,gBAAgB;QACrB,SAAS;IACX,GACC,IAAI;IACP,iBAAiB,4JAAQ;AAC3B,GACC,MAAM,MAAC,CAAC,OAAS,KAAK,QAAQ,KAAK,KAAK,eAAe,EAAE;IACxD,MAAM;QAAC;KAAkB;IACzB,SAAS;AACX;;AAeK,MAAM,kBAAkB,4JAAQ,CAAC;IACtC,gBAAgB,4JAAQ,GAAG,GAAG,CAAC,GAAG;QAAE,SAAS;IAAgC,GAAG,IAAI;IACpF,UAAU,4JAAQ,GAAG,GAAG,CAAC,GAAG;QAAE,SAAS;IAAuB,GAAG,IAAI;AACvE"}},
    {"offset": {"line": 83, "column": 0}, "map": {"version":3,"sources":["file:///home/gaetan/Bureau/ReactJS%20Experiences/hello-prisma/app/ui/login-form.tsx"],"sourcesContent":["\"use client\";\n\nimport { useState, useEffect } from \"react\";\nimport { useActionState } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { login } from \"../actions/auth\";\nimport { LoginFormSchema } from \"../lib/definitions\";\n\ntype StepKey = \"username_email\" | \"password\";\n\nconst steps: {\n  key: StepKey;\n  label: string;\n  type?: string;\n  placeholder?: string;\n}[] = [\n  {\n    key: \"username_email\",\n    label: \"Nom d'utilisateur ou email\",\n    placeholder: \"Nom d'utilisateur ou email\",\n  },\n  {\n    key: \"password\",\n    label: \"Mot de passe\",\n    type: \"password\",\n    placeholder: \"Votre mot de passe\",\n  },\n];\n\nexport default function LoginForm() {\n  const [state, action, pending] = useActionState(login, undefined);\n  const router = useRouter();\n\n  useEffect(() => {\n    if (state && (state as any).redirectTo) {\n      const target = (state as any).redirectTo as string;\n      if (target) router.push(target);\n    }\n  }, [state, router]);\n\n  const [stepIndex, setStepIndex] = useState(0);\n  const [values, setValues] = useState<Record<StepKey, string>>({\n    username_email: \"\",\n    password: \"\",\n  });\n  const [error, setError] = useState<string | null>(null);\n\n  const current = steps[stepIndex];\n\n  const getFieldSchema = (key: StepKey) => {\n    // access the zod shape for per-field validation\n    // @ts-ignore\n    return (LoginFormSchema as any).shape[key];\n  };\n\n  async function validateField(key: StepKey, value: string) {\n    setError(null);\n    try {\n      const schema = getFieldSchema(key);\n      if (!schema) return true;\n      schema.parse(value);\n      return true;\n    } catch (e: any) {\n      if (e?.issues && Array.isArray(e.issues)) {\n        setError(e.issues.map((i: any) => i.message).join(\" \"));\n      } else {\n        setError(e.message || \"Valeur invalide\");\n      }\n      return false;\n    }\n  }\n\n  async function onNext() {\n    const val = values[current.key];\n    const ok = await validateField(current.key, val);\n    if (!ok) return;\n    setStepIndex((s) => Math.min(s + 1, steps.length - 1));\n  }\n\n  function onBack() {\n    setError(null);\n    setStepIndex((s) => Math.max(0, s - 1));\n  }\n\n  function onChange(e: React.ChangeEvent<HTMLInputElement>) {\n    const v = e.target.value;\n    setValues((prev) => ({ ...prev, [current.key]: v }));\n    setError(null);\n  }\n\n  return (\n    <div className=\"min-h-screen flex items-center justify-center bg-gray-50 p-6\">\n      <div className=\"w-full max-w-md bg-white rounded-2xl shadow-lg p-6\">\n        <h1 className=\"text-center text-2xl font-bold mb-4\">Se connecter</h1>\n\n        <form action={action} method=\"post\" className=\"space-y-6\">\n          {/* progress */}\n          <div className=\"flex items-center gap-2 justify-center\">\n            {steps.map((s, i) => (\n              <div\n                key={s.key}\n                className={`h-2 w-8 rounded ${\n                  i <= stepIndex ? \"bg-indigo-600\" : \"bg-gray-200\"\n                }`}\n              ></div>\n            ))}\n          </div>\n\n          {/* visible field */}\n          <div>\n            <label className=\"block text-sm font-medium text-gray-700 mb-2\">\n              {current.label}\n            </label>\n            <input\n              autoFocus\n              name={current.key}\n              value={values[current.key]}\n              onChange={onChange}\n              type={current.type ?? \"text\"}\n              placeholder={current.placeholder}\n              className=\"w-full px-4 py-3 border rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500\"\n            />\n            {error && <p className=\"text-red-600 text-sm mt-2\">{error}</p>}\n          </div>\n\n          {/* hidden fields so final submit contains everything */}\n          {Object.entries(values).map(([k, v]) => (\n            <input key={k} type=\"hidden\" name={k} value={v} />\n          ))}\n\n          <div className=\"flex justify-between\">\n            <button\n              type=\"button\"\n              onClick={onBack}\n              disabled={stepIndex === 0}\n              className=\"px-4 py-2 rounded-lg border disabled:opacity-50\"\n            >\n              Retour\n            </button>\n            {stepIndex < steps.length - 1 ? (\n              <button\n                type=\"button\"\n                onClick={onNext}\n                className=\"px-4 py-2 bg-indigo-600 text-white rounded-lg\"\n              >\n                Suivant\n              </button>\n            ) : (\n              <button\n                type=\"submit\"\n                disabled={pending}\n                className=\"px-4 py-2 bg-indigo-600 text-white rounded-lg\"\n              >\n                {pending ? \"Connexion...\" : \"Se connecter\"}\n              </button>\n            )}\n          </div>\n\n          {state?.message && <p className=\"text-green-600\">{state.message}</p>}\n          {state?.errors && (\n            <div className=\"text-red-600 text-sm\">\n              {Object.entries(state.errors).map(([k, v]) => (\n                <p key={k}>\n                  {k}: {Array.isArray(v) ? v.join(\", \") : v}\n                </p>\n              ))}\n            </div>\n          )}\n        </form>\n      </div>\n    </div>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AAEA;AACA;AACA;;;AANA;;;;;;AAUA,MAAM,QAKA;IACJ;QACE,KAAK;QACL,OAAO;QACP,aAAa;IACf;IACA;QACE,KAAK;QACL,OAAO;QACP,MAAM;QACN,aAAa;IACf;CACD;AAEc,SAAS;;IACtB,MAAM,CAAC,OAAO,QAAQ,QAAQ,GAAG,IAAA,+KAAc,EAAC,kKAAK,EAAE;IACvD,MAAM,SAAS,IAAA,kJAAS;IAExB,IAAA,0KAAS;+BAAC;YACR,IAAI,SAAS,AAAC,MAAc,UAAU,EAAE;gBACtC,MAAM,SAAS,AAAC,MAAc,UAAU;gBACxC,IAAI,QAAQ,OAAO,IAAI,CAAC;YAC1B;QACF;8BAAG;QAAC;QAAO;KAAO;IAElB,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,yKAAQ,EAAC;IAC3C,MAAM,CAAC,QAAQ,UAAU,GAAG,IAAA,yKAAQ,EAA0B;QAC5D,gBAAgB;QAChB,UAAU;IACZ;IACA,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,yKAAQ,EAAgB;IAElD,MAAM,UAAU,KAAK,CAAC,UAAU;IAEhC,MAAM,iBAAiB,CAAC;QACtB,gDAAgD;QAChD,aAAa;QACb,OAAO,AAAC,+IAAe,CAAS,KAAK,CAAC,IAAI;IAC5C;IAEA,eAAe,cAAc,GAAY,EAAE,KAAa;QACtD,SAAS;QACT,IAAI;YACF,MAAM,SAAS,eAAe;YAC9B,IAAI,CAAC,QAAQ,OAAO;YACpB,OAAO,KAAK,CAAC;YACb,OAAO;QACT,EAAE,OAAO,GAAQ;YACf,IAAI,GAAG,UAAU,MAAM,OAAO,CAAC,EAAE,MAAM,GAAG;gBACxC,SAAS,EAAE,MAAM,CAAC,GAAG,CAAC,CAAC,IAAW,EAAE,OAAO,EAAE,IAAI,CAAC;YACpD,OAAO;gBACL,SAAS,EAAE,OAAO,IAAI;YACxB;YACA,OAAO;QACT;IACF;IAEA,eAAe;QACb,MAAM,MAAM,MAAM,CAAC,QAAQ,GAAG,CAAC;QAC/B,MAAM,KAAK,MAAM,cAAc,QAAQ,GAAG,EAAE;QAC5C,IAAI,CAAC,IAAI;QACT,aAAa,CAAC,IAAM,KAAK,GAAG,CAAC,IAAI,GAAG,MAAM,MAAM,GAAG;IACrD;IAEA,SAAS;QACP,SAAS;QACT,aAAa,CAAC,IAAM,KAAK,GAAG,CAAC,GAAG,IAAI;IACtC;IAEA,SAAS,SAAS,CAAsC;QACtD,MAAM,IAAI,EAAE,MAAM,CAAC,KAAK;QACxB,UAAU,CAAC,OAAS,CAAC;gBAAE,GAAG,IAAI;gBAAE,CAAC,QAAQ,GAAG,CAAC,EAAE;YAAE,CAAC;QAClD,SAAS;IACX;IAEA,qBACE,6LAAC;QAAI,WAAU;kBACb,cAAA,6LAAC;YAAI,WAAU;;8BACb,6LAAC;oBAAG,WAAU;8BAAsC;;;;;;8BAEpD,6LAAC;oBAAK,QAAQ;oBAAQ,QAAO;oBAAO,WAAU;;sCAE5C,6LAAC;4BAAI,WAAU;sCACZ,MAAM,GAAG,CAAC,CAAC,GAAG,kBACb,6LAAC;oCAEC,WAAW,CAAC,gBAAgB,EAC1B,KAAK,YAAY,kBAAkB,eACnC;mCAHG,EAAE,GAAG;;;;;;;;;;sCAShB,6LAAC;;8CACC,6LAAC;oCAAM,WAAU;8CACd,QAAQ,KAAK;;;;;;8CAEhB,6LAAC;oCACC,SAAS;oCACT,MAAM,QAAQ,GAAG;oCACjB,OAAO,MAAM,CAAC,QAAQ,GAAG,CAAC;oCAC1B,UAAU;oCACV,MAAM,QAAQ,IAAI,IAAI;oCACtB,aAAa,QAAQ,WAAW;oCAChC,WAAU;;;;;;gCAEX,uBAAS,6LAAC;oCAAE,WAAU;8CAA6B;;;;;;;;;;;;wBAIrD,OAAO,OAAO,CAAC,QAAQ,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,iBACjC,6LAAC;gCAAc,MAAK;gCAAS,MAAM;gCAAG,OAAO;+BAAjC;;;;;sCAGd,6LAAC;4BAAI,WAAU;;8CACb,6LAAC;oCACC,MAAK;oCACL,SAAS;oCACT,UAAU,cAAc;oCACxB,WAAU;8CACX;;;;;;gCAGA,YAAY,MAAM,MAAM,GAAG,kBAC1B,6LAAC;oCACC,MAAK;oCACL,SAAS;oCACT,WAAU;8CACX;;;;;yDAID,6LAAC;oCACC,MAAK;oCACL,UAAU;oCACV,WAAU;8CAET,UAAU,iBAAiB;;;;;;;;;;;;wBAKjC,OAAO,yBAAW,6LAAC;4BAAE,WAAU;sCAAkB,MAAM,OAAO;;;;;;wBAC9D,OAAO,wBACN,6LAAC;4BAAI,WAAU;sCACZ,OAAO,OAAO,CAAC,MAAM,MAAM,EAAE,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,iBACvC,6LAAC;;wCACE;wCAAE;wCAAG,MAAM,OAAO,CAAC,KAAK,EAAE,IAAI,CAAC,QAAQ;;mCADlC;;;;;;;;;;;;;;;;;;;;;;;;;;;AAUxB;GA/IwB;;QACW,+KAAc;QAChC,kJAAS;;;KAFF"}}]
}